{"ast":null,"code":"import _objectSpread from \"/home/user/Documents/frontend-preyana/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport flightData from './../data.json';\nimport { transformFlightDates } from './utils';\n\n//Using a graph algorithm to recursively explore all the connected nodes and find all connected flight paths\nfunction paths({\n  graph = [],\n  from,\n  to,\n  date\n}, path = []) {\n  const linkedNodes = connectedNodes(nodes.bind(null, graph));\n  return explore(from, to);\n  function explore(currNode, to, paths = [], originalNode) {\n    path.push(originalNode || currNode);\n    for (let linkedNode of linkedNodes(currNode)) {\n      if (linkedNode.destination === to) {\n        let result = path.slice(); // copy values\n        result.push(_objectSpread({}, linkedNode));\n        paths.push(result);\n        continue;\n      }\n      // do not traverse paths already explored\n      if (!hasEdgeBeenTraversedInPath({\n        edge: {\n          from: currNode,\n          to: linkedNode.destination\n        },\n        path: path.map(a => a && a.destination ? a.destination : a)\n      })) {\n        explore(linkedNode.destination, to, paths, linkedNode);\n      }\n    }\n    path.pop(); // sub-graph fully explored \n\n    return paths;\n  }\n}\n\n/** \n* Get all nodes linked \n* to from `node`.\n*/\nfunction nodes(graph, node) {\n  const list = graph.reduce((p, c) => {\n    c.origin === node && p.push({\n      destination: c.destination,\n      config: _objectSpread({}, c)\n    });\n    return p;\n  }, []);\n  return list;\n}\n\n/**\n* Has an edge been followed \n* in the given path?\n*/\nfunction hasEdgeBeenTraversedInPath({\n  edge,\n  path\n}) {\n  var indices = allIndices(path, edge.from);\n  return indices.some(i => path[i + 1] === edge.to);\n}\n\n/**\n* Utility to get all indices of \n* values matching `val` in `arr`.\n*/\nfunction allIndices(arr, value) {\n  var indices = [],\n    i;\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      indices.push(i);\n    }\n  }\n  return indices;\n}\n\n/**\n* Avoids recalculating flight route \n* nodes.\n*/\nfunction connectedNodes(fn) {\n  const flightCache = new Map();\n  return function () {\n    var key = JSON.stringify(arguments);\n    var cached = flightCache.get(key);\n    if (cached) {\n      return cached;\n    }\n    cached = fn.apply(this, arguments);\n    flightCache.set(key, cached);\n    return cached;\n  };\n}\nfunction filterPaths(paths, date, numOfPassengers) {\n  const list = paths.filter(path => {\n    return isSameDestination(path);\n  });\n  const finalPaths = list.filter(path => {\n    return checkLayoverCriteria(path, date);\n  });\n  const transformedPaths = {\n    nonStopFlights: [],\n    multiStopFlights: []\n  };\n  finalPaths.forEach((path, index) => {\n    if (path.length === 2) {\n      transformedPaths.nonStopFlights.push(_objectSpread({}, path[1].config, {\n        price: path[1].config.price * (parseInt(numOfPassengers) || 1)\n      }));\n    } else {\n      let totalFare = 0,\n        multiFlights = [],\n        layovers = path.length - 1;\n      for (let i = 1; i < path.length; i++) {\n        multiFlights.push(_objectSpread({}, path[i].config));\n        totalFare += path[i].config.price;\n      }\n      transformedPaths.multiStopFlights.push({\n        cumulativeFlight: {\n          origin: path[0],\n          destination: path[layovers].destination,\n          date: path[1].config.date,\n          departureTime: path[1].config.departureTime,\n          arrivalTime: path[layovers].config.arrivalTime,\n          arrivalTimeStamp: path[layovers].config.arrivalTimeStamp,\n          departureTimeStamp: path[1].config.departureTimeStamp,\n          dayChange: path[1].config.date !== path[layovers].config.date,\n          totalFare: totalFare * (parseInt(numOfPassengers) || 1)\n        },\n        flights: multiFlights\n      });\n    }\n    return transformedPaths;\n  });\n  return transformedPaths;\n}\nfunction checkLayoverCriteria(path, startDate) {\n  let lowerLayover = false;\n  if (path.length > 1 && path[1].config.date !== startDate.replace(/-/g, '/')) {\n    return false;\n  }\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof path[i] === \"object\" && typeof path[i + 1] === \"object\" && path[i + 1].config.departureTimeStamp - path[i].config.arrivalTimeStamp <= 1800000) {\n      lowerLayover = true;\n      break;\n    }\n  }\n  return !lowerLayover;\n}\nfunction isSameDestination(links) {\n  let duplicate = false;\n  let keys = {};\n  for (let i = 0; i < links.length; i++) {\n    const keyName = links[i] && links[i].destination ? links[i].destination : links[i];\n    if (keys.hasOwnProperty(keyName)) {\n      duplicate = true;\n      break;\n    }\n    keys[keyName] = links[i];\n  }\n  return !duplicate;\n}\nexport function findPaths({\n  flights = transformFlightDates(flightData),\n  criteria\n}) {\n  return filterPaths(paths({\n    graph: flights,\n    from: criteria.origin,\n    to: criteria.destination\n  }), criteria.date, criteria.numOfPassengers);\n}","map":{"version":3,"names":["flightData","transformFlightDates","paths","graph","from","to","date","path","linkedNodes","connectedNodes","nodes","bind","explore","currNode","originalNode","push","linkedNode","destination","result","slice","_objectSpread","hasEdgeBeenTraversedInPath","edge","map","a","pop","node","list","reduce","p","c","origin","config","indices","allIndices","some","i","arr","value","length","fn","flightCache","Map","key","JSON","stringify","arguments","cached","get","apply","set","filterPaths","numOfPassengers","filter","isSameDestination","finalPaths","checkLayoverCriteria","transformedPaths","nonStopFlights","multiStopFlights","forEach","index","price","parseInt","totalFare","multiFlights","layovers","cumulativeFlight","departureTime","arrivalTime","arrivalTimeStamp","departureTimeStamp","dayChange","flights","startDate","lowerLayover","replace","links","duplicate","keys","keyName","hasOwnProperty","findPaths","criteria"],"sources":["/home/user/Documents/frontend-preyana/src/lib/flightManager.js"],"sourcesContent":["import flightData from './../data.json';\nimport { transformFlightDates } from './utils';\n\n//Using a graph algorithm to recursively explore all the connected nodes and find all connected flight paths\nfunction paths({ graph = [], from, to, date }, path = []) {\n  const linkedNodes = connectedNodes(nodes.bind(null, graph));\n  return explore(from, to);\n\n  function explore(currNode, to, paths = [], originalNode) {\n    path.push(originalNode || currNode);\n    for (let linkedNode of linkedNodes(currNode)) {\n      if (linkedNode.destination === to) {\n        let result = path.slice(); // copy values\n        result.push({ ...linkedNode });\n        paths.push(result);\n        continue;\n      }\n      // do not traverse paths already explored\n      if (!hasEdgeBeenTraversedInPath({\n        edge: {\n          from: currNode,\n          to: linkedNode.destination\n        },\n        path: path.map(a => a && a.destination ? a.destination : a)\n      })) {\n        explore(linkedNode.destination, to, paths, linkedNode);\n      }\n    }\n    path.pop(); // sub-graph fully explored \n\n    return paths;\n  }\n}\n\n/** \n* Get all nodes linked \n* to from `node`.\n*/\nfunction nodes(graph, node) {\n  const list = graph.reduce((p, c) => {\n    (c.origin === node) && p.push({ destination: c.destination, config: { ...c } });\n    return p;\n  }, []);\n  return list;\n}\n\n/**\n* Has an edge been followed \n* in the given path?\n*/\nfunction hasEdgeBeenTraversedInPath({ edge, path }) {\n  var indices = allIndices(path, edge.from);\n  return indices.some(i => path[i + 1] === edge.to);\n}\n\n/**\n* Utility to get all indices of \n* values matching `val` in `arr`.\n*/\nfunction allIndices(arr, value) {\n  var indices = [],\n    i;\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      indices.push(i);\n    }\n  }\n  return indices;\n}\n\n/**\n* Avoids recalculating flight route \n* nodes.\n*/\nfunction connectedNodes(fn) {\n  const flightCache = new Map();\n  return function () {\n    var key = JSON.stringify(arguments);\n    var cached = flightCache.get(key);\n    if (cached) {\n      return cached;\n    }\n    cached = fn.apply(this, arguments)\n    flightCache.set(key, cached);\n    return cached;\n  };\n}\n\nfunction filterPaths(paths, date, numOfPassengers) {\n\n  const list = paths.filter(path => {\n    return isSameDestination(path);\n  });\n\n  const finalPaths = list.filter(path => {\n    return checkLayoverCriteria(path, date);\n  });\n\n  const transformedPaths = {\n    nonStopFlights: [],\n    multiStopFlights: [],\n  }\n\n  finalPaths.forEach((path, index) => {\n    if (path.length === 2) {\n      transformedPaths.nonStopFlights.push({\n        ...path[1].config,\n        price: path[1].config.price * (parseInt(numOfPassengers) || 1)\n      })\n    }\n    else {\n      let totalFare = 0, multiFlights = [], layovers = path.length - 1;\n      for (let i = 1; i < path.length; i++) {\n        multiFlights.push({ ...path[i].config });\n        totalFare += path[i].config.price;\n      }\n\n      transformedPaths.multiStopFlights.push({\n        cumulativeFlight: {\n          origin: path[0],\n          destination: path[layovers].destination,\n          date: path[1].config.date,\n          departureTime: path[1].config.departureTime,\n          arrivalTime: path[layovers].config.arrivalTime,\n          arrivalTimeStamp: path[layovers].config.arrivalTimeStamp,\n          departureTimeStamp: path[1].config.departureTimeStamp,\n          dayChange: path[1].config.date !== path[layovers].config.date,\n          totalFare: totalFare * (parseInt(numOfPassengers) || 1)\n        },\n        flights: multiFlights\n      })\n    }\n\n    return transformedPaths;\n  });\n\n  return transformedPaths;\n}\n\nfunction checkLayoverCriteria(path, startDate) {\n  let lowerLayover = false;\n\n  if (path.length > 1 && (path[1].config.date !== startDate.replace(/-/g, '/'))) {\n    return false;\n  }\n\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof path[i] === \"object\" && typeof path[i + 1] === \"object\" && path[i + 1].config.departureTimeStamp - path[i].config.arrivalTimeStamp <= 1800000) {\n      lowerLayover = true;\n      break;\n    }\n  }\n\n  return !lowerLayover;\n}\n\nfunction isSameDestination(links) {\n  let duplicate = false;\n  let keys = {};\n  for (let i = 0; i < links.length; i++) {\n    const keyName = links[i] && links[i].destination ? links[i].destination : links[i];\n    if (keys.hasOwnProperty(keyName)) {\n      duplicate = true;\n      break;\n    }\n    keys[keyName] = links[i]\n  }\n  return !duplicate;\n}\n\nexport function findPaths({ flights = transformFlightDates(flightData), criteria  }) {\n  return filterPaths(paths({\n    graph: flights,\n    from: criteria.origin,\n    to: criteria.destination,\n  }), criteria.date, criteria.numOfPassengers)\n}\n\n"],"mappings":";AAAA,OAAOA,UAAU,MAAM,gBAAgB;AACvC,SAASC,oBAAoB,QAAQ,SAAS;;AAE9C;AACA,SAASC,KAAKA,CAAC;EAAEC,KAAK,GAAG,EAAE;EAAEC,IAAI;EAAEC,EAAE;EAAEC;AAAK,CAAC,EAAEC,IAAI,GAAG,EAAE,EAAE;EACxD,MAAMC,WAAW,GAAGC,cAAc,CAACC,KAAK,CAACC,IAAI,CAAC,IAAI,EAAER,KAAK,CAAC,CAAC;EAC3D,OAAOS,OAAO,CAACR,IAAI,EAAEC,EAAE,CAAC;EAExB,SAASO,OAAOA,CAACC,QAAQ,EAAER,EAAE,EAAEH,KAAK,GAAG,EAAE,EAAEY,YAAY,EAAE;IACvDP,IAAI,CAACQ,IAAI,CAACD,YAAY,IAAID,QAAQ,CAAC;IACnC,KAAK,IAAIG,UAAU,IAAIR,WAAW,CAACK,QAAQ,CAAC,EAAE;MAC5C,IAAIG,UAAU,CAACC,WAAW,KAAKZ,EAAE,EAAE;QACjC,IAAIa,MAAM,GAAGX,IAAI,CAACY,KAAK,CAAC,CAAC,CAAC,CAAC;QAC3BD,MAAM,CAACH,IAAI,CAAAK,aAAA,KAAMJ,UAAU,CAAE,CAAC;QAC9Bd,KAAK,CAACa,IAAI,CAACG,MAAM,CAAC;QAClB;MACF;MACA;MACA,IAAI,CAACG,0BAA0B,CAAC;QAC9BC,IAAI,EAAE;UACJlB,IAAI,EAAES,QAAQ;UACdR,EAAE,EAAEW,UAAU,CAACC;QACjB,CAAC;QACDV,IAAI,EAAEA,IAAI,CAACgB,GAAG,CAACC,CAAC,IAAIA,CAAC,IAAIA,CAAC,CAACP,WAAW,GAAGO,CAAC,CAACP,WAAW,GAAGO,CAAC;MAC5D,CAAC,CAAC,EAAE;QACFZ,OAAO,CAACI,UAAU,CAACC,WAAW,EAAEZ,EAAE,EAAEH,KAAK,EAAEc,UAAU,CAAC;MACxD;IACF;IACAT,IAAI,CAACkB,GAAG,CAAC,CAAC,CAAC,CAAC;;IAEZ,OAAOvB,KAAK;EACd;AACF;;AAEA;AACA;AACA;AACA;AACA,SAASQ,KAAKA,CAACP,KAAK,EAAEuB,IAAI,EAAE;EAC1B,MAAMC,IAAI,GAAGxB,KAAK,CAACyB,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;IACjCA,CAAC,CAACC,MAAM,KAAKL,IAAI,IAAKG,CAAC,CAACd,IAAI,CAAC;MAAEE,WAAW,EAAEa,CAAC,CAACb,WAAW;MAAEe,MAAM,EAAAZ,aAAA,KAAOU,CAAC;IAAG,CAAC,CAAC;IAC/E,OAAOD,CAAC;EACV,CAAC,EAAE,EAAE,CAAC;EACN,OAAOF,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA,SAASN,0BAA0BA,CAAC;EAAEC,IAAI;EAAEf;AAAK,CAAC,EAAE;EAClD,IAAI0B,OAAO,GAAGC,UAAU,CAAC3B,IAAI,EAAEe,IAAI,CAAClB,IAAI,CAAC;EACzC,OAAO6B,OAAO,CAACE,IAAI,CAACC,CAAC,IAAI7B,IAAI,CAAC6B,CAAC,GAAG,CAAC,CAAC,KAAKd,IAAI,CAACjB,EAAE,CAAC;AACnD;;AAEA;AACA;AACA;AACA;AACA,SAAS6B,UAAUA,CAACG,GAAG,EAAEC,KAAK,EAAE;EAC9B,IAAIL,OAAO,GAAG,EAAE;IACdG,CAAC;EACH,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,GAAG,CAACE,MAAM,EAAEH,CAAC,EAAE,EAAE;IAC/B,IAAIC,GAAG,CAACD,CAAC,CAAC,KAAKE,KAAK,EAAE;MACpBL,OAAO,CAAClB,IAAI,CAACqB,CAAC,CAAC;IACjB;EACF;EACA,OAAOH,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA,SAASxB,cAAcA,CAAC+B,EAAE,EAAE;EAC1B,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC7B,OAAO,YAAY;IACjB,IAAIC,GAAG,GAAGC,IAAI,CAACC,SAAS,CAACC,SAAS,CAAC;IACnC,IAAIC,MAAM,GAAGN,WAAW,CAACO,GAAG,CAACL,GAAG,CAAC;IACjC,IAAII,MAAM,EAAE;MACV,OAAOA,MAAM;IACf;IACAA,MAAM,GAAGP,EAAE,CAACS,KAAK,CAAC,IAAI,EAAEH,SAAS,CAAC;IAClCL,WAAW,CAACS,GAAG,CAACP,GAAG,EAAEI,MAAM,CAAC;IAC5B,OAAOA,MAAM;EACf,CAAC;AACH;AAEA,SAASI,WAAWA,CAACjD,KAAK,EAAEI,IAAI,EAAE8C,eAAe,EAAE;EAEjD,MAAMzB,IAAI,GAAGzB,KAAK,CAACmD,MAAM,CAAC9C,IAAI,IAAI;IAChC,OAAO+C,iBAAiB,CAAC/C,IAAI,CAAC;EAChC,CAAC,CAAC;EAEF,MAAMgD,UAAU,GAAG5B,IAAI,CAAC0B,MAAM,CAAC9C,IAAI,IAAI;IACrC,OAAOiD,oBAAoB,CAACjD,IAAI,EAAED,IAAI,CAAC;EACzC,CAAC,CAAC;EAEF,MAAMmD,gBAAgB,GAAG;IACvBC,cAAc,EAAE,EAAE;IAClBC,gBAAgB,EAAE;EACpB,CAAC;EAEDJ,UAAU,CAACK,OAAO,CAAC,CAACrD,IAAI,EAAEsD,KAAK,KAAK;IAClC,IAAItD,IAAI,CAACgC,MAAM,KAAK,CAAC,EAAE;MACrBkB,gBAAgB,CAACC,cAAc,CAAC3C,IAAI,CAAAK,aAAA,KAC/Bb,IAAI,CAAC,CAAC,CAAC,CAACyB,MAAM;QACjB8B,KAAK,EAAEvD,IAAI,CAAC,CAAC,CAAC,CAACyB,MAAM,CAAC8B,KAAK,IAAIC,QAAQ,CAACX,eAAe,CAAC,IAAI,CAAC;MAAC,EAC/D,CAAC;IACJ,CAAC,MACI;MACH,IAAIY,SAAS,GAAG,CAAC;QAAEC,YAAY,GAAG,EAAE;QAAEC,QAAQ,GAAG3D,IAAI,CAACgC,MAAM,GAAG,CAAC;MAChE,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,IAAI,CAACgC,MAAM,EAAEH,CAAC,EAAE,EAAE;QACpC6B,YAAY,CAAClD,IAAI,CAAAK,aAAA,KAAMb,IAAI,CAAC6B,CAAC,CAAC,CAACJ,MAAM,CAAE,CAAC;QACxCgC,SAAS,IAAIzD,IAAI,CAAC6B,CAAC,CAAC,CAACJ,MAAM,CAAC8B,KAAK;MACnC;MAEAL,gBAAgB,CAACE,gBAAgB,CAAC5C,IAAI,CAAC;QACrCoD,gBAAgB,EAAE;UAChBpC,MAAM,EAAExB,IAAI,CAAC,CAAC,CAAC;UACfU,WAAW,EAAEV,IAAI,CAAC2D,QAAQ,CAAC,CAACjD,WAAW;UACvCX,IAAI,EAAEC,IAAI,CAAC,CAAC,CAAC,CAACyB,MAAM,CAAC1B,IAAI;UACzB8D,aAAa,EAAE7D,IAAI,CAAC,CAAC,CAAC,CAACyB,MAAM,CAACoC,aAAa;UAC3CC,WAAW,EAAE9D,IAAI,CAAC2D,QAAQ,CAAC,CAAClC,MAAM,CAACqC,WAAW;UAC9CC,gBAAgB,EAAE/D,IAAI,CAAC2D,QAAQ,CAAC,CAAClC,MAAM,CAACsC,gBAAgB;UACxDC,kBAAkB,EAAEhE,IAAI,CAAC,CAAC,CAAC,CAACyB,MAAM,CAACuC,kBAAkB;UACrDC,SAAS,EAAEjE,IAAI,CAAC,CAAC,CAAC,CAACyB,MAAM,CAAC1B,IAAI,KAAKC,IAAI,CAAC2D,QAAQ,CAAC,CAAClC,MAAM,CAAC1B,IAAI;UAC7D0D,SAAS,EAAEA,SAAS,IAAID,QAAQ,CAACX,eAAe,CAAC,IAAI,CAAC;QACxD,CAAC;QACDqB,OAAO,EAAER;MACX,CAAC,CAAC;IACJ;IAEA,OAAOR,gBAAgB;EACzB,CAAC,CAAC;EAEF,OAAOA,gBAAgB;AACzB;AAEA,SAASD,oBAAoBA,CAACjD,IAAI,EAAEmE,SAAS,EAAE;EAC7C,IAAIC,YAAY,GAAG,KAAK;EAExB,IAAIpE,IAAI,CAACgC,MAAM,GAAG,CAAC,IAAKhC,IAAI,CAAC,CAAC,CAAC,CAACyB,MAAM,CAAC1B,IAAI,KAAKoE,SAAS,CAACE,OAAO,CAAC,IAAI,EAAE,GAAG,CAAE,EAAE;IAC7E,OAAO,KAAK;EACd;EAEA,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,IAAI,CAACgC,MAAM,GAAG,CAAC,EAAEH,CAAC,EAAE,EAAE;IACxC,IAAI,OAAO7B,IAAI,CAAC6B,CAAC,CAAC,KAAK,QAAQ,IAAI,OAAO7B,IAAI,CAAC6B,CAAC,GAAG,CAAC,CAAC,KAAK,QAAQ,IAAI7B,IAAI,CAAC6B,CAAC,GAAG,CAAC,CAAC,CAACJ,MAAM,CAACuC,kBAAkB,GAAGhE,IAAI,CAAC6B,CAAC,CAAC,CAACJ,MAAM,CAACsC,gBAAgB,IAAI,OAAO,EAAE;MACxJK,YAAY,GAAG,IAAI;MACnB;IACF;EACF;EAEA,OAAO,CAACA,YAAY;AACtB;AAEA,SAASrB,iBAAiBA,CAACuB,KAAK,EAAE;EAChC,IAAIC,SAAS,GAAG,KAAK;EACrB,IAAIC,IAAI,GAAG,CAAC,CAAC;EACb,KAAK,IAAI3C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyC,KAAK,CAACtC,MAAM,EAAEH,CAAC,EAAE,EAAE;IACrC,MAAM4C,OAAO,GAAGH,KAAK,CAACzC,CAAC,CAAC,IAAIyC,KAAK,CAACzC,CAAC,CAAC,CAACnB,WAAW,GAAG4D,KAAK,CAACzC,CAAC,CAAC,CAACnB,WAAW,GAAG4D,KAAK,CAACzC,CAAC,CAAC;IAClF,IAAI2C,IAAI,CAACE,cAAc,CAACD,OAAO,CAAC,EAAE;MAChCF,SAAS,GAAG,IAAI;MAChB;IACF;IACAC,IAAI,CAACC,OAAO,CAAC,GAAGH,KAAK,CAACzC,CAAC,CAAC;EAC1B;EACA,OAAO,CAAC0C,SAAS;AACnB;AAEA,OAAO,SAASI,SAASA,CAAC;EAAET,OAAO,GAAGxE,oBAAoB,CAACD,UAAU,CAAC;EAAEmF;AAAU,CAAC,EAAE;EACnF,OAAOhC,WAAW,CAACjD,KAAK,CAAC;IACvBC,KAAK,EAAEsE,OAAO;IACdrE,IAAI,EAAE+E,QAAQ,CAACpD,MAAM;IACrB1B,EAAE,EAAE8E,QAAQ,CAAClE;EACf,CAAC,CAAC,EAAEkE,QAAQ,CAAC7E,IAAI,EAAE6E,QAAQ,CAAC/B,eAAe,CAAC;AAC9C"},"metadata":{},"sourceType":"module"}